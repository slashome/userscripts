"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var createValidator_exports = {};
__export(createValidator_exports, {
  createValidator: () => createValidator
});
module.exports = __toCommonJS(createValidator_exports);
var import_parse = require("./parse");
function isRunOnce(validator, runOnce) {
  return runOnce;
}
function createValidator({
  name,
  required = false,
  validator = false,
  messages = {},
  fixable = false,
  regexMatch = new RegExp(
    "^(" + (typeof name === "string" ? name : name.join("|")) + ")$"
  ),
  runOnce = false,
  description,
  schema
}) {
  const nameList = typeof name === "string" ? [name] : name;
  return {
    meta: {
      type: "suggestion",
      docs: {
        description: description || `${required ? `require ${validator ? "and validate " : ""}` : "validate "}${nameList.join(" and ")} in the metadata for userscripts`,
        category: "Best Practices"
      },
      schema: required ? [
        {
          enum: ["required", "optional"],
          default: "required"
        }
      ] : schema || void 0,
      messages: {
        missingAttribute: `Didn't find attribute '${nameList}' in the metadata`,
        ...messages
      },
      fixable: fixable ? "code" : void 0
    },
    create: (context) => {
      const sourceCode = context.sourceCode;
      const comments = sourceCode.getAllComments();
      const result = (0, import_parse.parse)(sourceCode);
      const metadata = {};
      const lines = result.lines.filter(
        (line) => line.metadataInfo
      );
      for (const line of lines) {
        const actualValue = line.value.trim().slice(2);
        const lengthDiff = line.value.length - actualValue.length - 2;
        const newLoc = {
          start: {
            line: line.lineLoc.start.line,
            column: line.lineLoc.start.column + lengthDiff
          },
          end: line.lineLoc.end
        };
        const metadataVal = {
          val: line.metadataValue.value,
          loc: newLoc,
          comment: {
            value: actualValue,
            range: [
              sourceCode.getIndexFromLoc(line.lineLoc.start) + lengthDiff,
              sourceCode.getIndexFromLoc(line.lineLoc.end)
            ],
            loc: newLoc,
            type: "Line"
          },
          key: line.metadataValue.key
        };
        if (metadata[line.metadataValue.key]) {
          if (!Array.isArray(metadata[line.metadataValue.key])) {
            metadata[line.metadataValue.key] = [
              metadata[line.metadataValue.key]
            ];
          }
          metadata[line.metadataValue.key].push(metadataVal);
          continue;
        }
        metadata[line.metadataValue.key] = metadataVal;
      }
      const metadataKeys = Object.keys(metadata);
      const startComment = comments.find(
        (comment) => comment.value.trim() === "==UserScript==" && comment.type === "Line"
      );
      if (required && result.enteredMetadata !== -1 && startComment && startComment.loc && (!context.options[0] || context.options[0] === "required") && !metadataKeys.some(
        (metadataKeyName) => regexMatch.test(metadataKeyName)
      )) {
        context.report({
          loc: startComment.loc,
          messageId: "missingAttribute"
        });
      } else if (validator && metadataKeys.some((metadataKeyName) => regexMatch.test(metadataKeyName))) {
        if (isRunOnce(validator, runOnce)) {
          const matchingMetadataKeyIndex = [];
          for (const metadataKeyIndex in metadataKeys) {
            if (regexMatch.test(metadataKeys[metadataKeyIndex])) {
              matchingMetadataKeyIndex.push(+metadataKeyIndex);
            }
          }
          const attributeValues = matchingMetadataKeyIndex.flatMap(
            (index) => metadata[metadataKeys[index]]
          );
          validator({
            attrVal: attributeValues,
            index: [...attributeValues.keys()],
            metadata,
            context,
            keyName: matchingMetadataKeyIndex.map(
              (index) => metadataKeys[index]
            )
          });
        } else {
          for (const metadataKeyIndex in metadataKeys) {
            if (!regexMatch.test(metadataKeys[metadataKeyIndex])) {
              continue;
            }
            if (Array.isArray(metadata[metadataKeys[metadataKeyIndex]])) {
              for (const [index, attrVal] of metadata[metadataKeys[metadataKeyIndex]].entries()) {
                validator({
                  attrVal,
                  index,
                  metadata,
                  context,
                  keyName: metadataKeys[metadataKeyIndex]
                });
              }
            } else {
              validator({
                attrVal: metadata[metadataKeys[metadataKeyIndex]],
                index: 0,
                metadata,
                context,
                keyName: metadataKeys[metadataKeyIndex]
              });
            }
          }
        }
      }
      return {};
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createValidator
});
