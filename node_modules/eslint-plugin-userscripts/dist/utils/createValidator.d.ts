import * as json_schema from 'json-schema';
import { SourceLocation } from './parse.js';
import { Rule } from 'eslint';

type JSONSchema4 = Rule.RuleMetaData['schema'];
type Metadata = {
    comment: {
        loc: SourceLocation;
        type: 'Line';
        range: [number, number];
        value: string;
    };
    loc: SourceLocation;
    val: string;
    key: string;
};
type ValidatorCallback<SingleCall extends boolean> = (validationInfo: {
    attrVal: SingleCall extends true ? Metadata[] : Metadata;
    index: SingleCall extends true ? number[] : number;
    metadata: Record<string, Metadata | Metadata[]>;
    context: Rule.RuleContext;
    keyName: SingleCall extends true ? string[] : string;
}) => void;
interface Options {
    /**
     * Name of the attribute to validate
     */
    name: string | string[];
    /**
     * Description of the rule
     */
    description?: string;
    /**
     * Whether the attribute is required, this will ignore your custom validator and use the default one
     */
    required?: boolean;
    /**
     * Message ID to message template mapping
     *
     * @see https://eslint.org/docs/latest/extend/custom-rules#using-message-placeholders
     */
    messages?: Record<string, string>;
    /**
     * Custom regular expression that the attribute name must match
     * Overrides the `name` option
     */
    regexMatch?: RegExp;
    /**
     * Whether the rule is fixable or not, adds in metadata property `fix`
     */
    fixable?: boolean;
    /**
     * JSON Schema to validate attribute options
     */
    schema?: JSONSchema4;
}
interface OptionsRunOnce extends Options {
    /**
     * Custom validator function, if using `runOnce` this will be called once with all matching attributes
     */
    validator?: ValidatorCallback</* SingleCall */ true> | false;
    /**
     * Whether to run the validator once or for each attribute
     */
    runOnce: true;
}
interface OptionsRunMultiple extends Options {
    /**
     * Custom validator function, if using `runOnce` this will be called once with all matching attributes
     */
    validator?: ValidatorCallback</* SingleCall */ false> | false;
    /**
     * Whether to run the validator once or for each attribute
     */
    runOnce?: false;
}
/**
 * Creates a rule that validates metadata
 *
 * @example
 * ```ts
 * // Basic example that requires homepageURL if homepage is present
 * export default createValidator({
 *    name: 'homepage',
 *    required: false,
 *    validator: ({ attrVal, context, metadata }) => {
 *        if (!('homepageURL' in metadata)) {
 *            context.report({
 *               loc: attrVal.loc,
 *               messageId: 'missingAttribute',
 *               data: {
 *                   attribute: 'homepageURL'
 *               },
 *            });
 *        }
 *    },
 * });
 * ```
 *
 * @returns Rule including metadata and rule function
 */
declare function createValidator({ name, required, validator, messages, fixable, regexMatch, runOnce, description, schema }: OptionsRunMultiple | OptionsRunOnce): {
    meta: {
        type: "suggestion";
        docs: {
            description: string;
            category: string;
        };
        schema: json_schema.JSONSchema4 | json_schema.JSONSchema4[] | undefined;
        messages: {
            missingAttribute: string;
        };
        fixable: "code" | undefined;
    };
    create: (context: Rule.RuleContext) => Record<string, never>;
};

export { type Metadata, createValidator };
