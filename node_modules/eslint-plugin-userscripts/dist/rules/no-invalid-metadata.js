"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var no_invalid_metadata_exports = {};
__export(no_invalid_metadata_exports, {
  default: () => no_invalid_metadata_default
});
module.exports = __toCommonJS(no_invalid_metadata_exports);
var import_parse = require("../utils/parse");
var no_invalid_metadata_default = {
  meta: {
    type: "suggestion",
    docs: {
      description: "ensure userscripts have valid metadata",
      category: "Possible Errors"
    },
    messages: {
      metadataRequired: "Add metadata to the userscript",
      moveMetadataToTop: "Move the metadata to the top of the file",
      noClosingMetadata: "Closing metadata comment not found",
      noCodeBetween: "Code found between in metadata",
      attributeNotStartsWithAtTheRate: "Attributes should begin with @"
    },
    schema: [
      {
        type: "object",
        properties: {
          top: {
            enum: ["required", "optional"],
            default: "required"
          }
        },
        additionalProperties: false
      }
    ]
  },
  create: (context) => {
    const sourceCode = context.sourceCode;
    const comments = sourceCode.getAllComments();
    const result = (0, import_parse.parse)(sourceCode);
    for (const { lineLoc, codeBetween } of result.lines) {
      if (!codeBetween) {
        continue;
      }
      context.report({
        loc: lineLoc,
        messageId: "noCodeBetween"
      });
    }
    for (const { lineLoc, invalid } of result.lines) {
      if (!invalid) {
        continue;
      }
      context.report({
        loc: lineLoc,
        messageId: "attributeNotStartsWithAtTheRate"
      });
    }
    const startComment = comments.find(
      (comment) => comment.value.trim() === "==UserScript==" && comment.type === "Line"
    );
    if (startComment && startComment.loc && result.enteredMetadata !== -1 && !result.end) {
      context.report({
        loc: startComment.loc,
        messageId: "noClosingMetadata"
      });
    }
    const firstComment = comments.find((comment) => {
      return comment.loc;
    });
    return {
      Program(node) {
        if (result.enteredMetadata === -1 || !firstComment) {
          context.report({
            node,
            messageId: "metadataRequired"
          });
        } else if ((!context.options[0] || !context.options[0].top || context.options[0].top === "required") && (result.enteredMetadata !== 0 || firstComment.loc.start.line !== 1)) {
          const firstStartComment = comments.find(
            (comment) => comment.value.trim() === "==UserScript==" && comment.type === "Line"
          );
          if (firstStartComment) {
            context.report({
              loc: firstStartComment.loc,
              messageId: "moveMetadataToTop"
            });
          } else {
            context.report({
              loc: firstComment.loc,
              messageId: "moveMetadataToTop"
            });
          }
        }
      }
    };
  }
};
