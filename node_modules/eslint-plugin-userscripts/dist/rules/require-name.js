"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var require_name_exports = {};
__export(require_name_exports, {
  default: () => require_name_default
});
module.exports = __toCommonJS(require_name_exports);
var import_createValidator = require("../utils/createValidator");
const nameReg = /^name(:[A-Za-z-]+)?$/;
var require_name_default = (0, import_createValidator.createValidator)({
  name: ["name"],
  required: true,
  validator: ({ attrVal, context, metadata }) => {
    const iteratedKeyNames = /* @__PURE__ */ new Set();
    for (const attrValue of attrVal) {
      if (iteratedKeyNames.has(attrValue.key)) {
        context.report({
          loc: attrValue.loc,
          messageId: "multipleNames"
        });
      } else {
        iteratedKeyNames.add(attrValue.key);
      }
    }
    const metadataValues = Object.values(metadata).map((attrValue) => {
      return Array.isArray(attrValue) ? attrValue[0] : attrValue;
    });
    const sourceCode = context.sourceCode;
    const comments = sourceCode.getAllComments();
    const startComment = comments.find(
      (comment) => comment.value.trim() === "==UserScript==" && comment.type === "Line"
    );
    let unorderedNames = false;
    for (const [attrValIndex, attrValue] of metadataValues.entries()) {
      if (attrValIndex > 0 && nameReg.test(attrValue.key) && !nameReg.test(metadataValues[attrValIndex - 1].key)) {
        unorderedNames = true;
        break;
      }
    }
    if (startComment && unorderedNames) {
      const endingMetadataComment = comments.find(
        (comment) => comment.value.trim() === "==/UserScript==" && comment.type === "Line"
      );
      context.report({
        loc: {
          start: startComment.loc.start,
          end: endingMetadataComment ? endingMetadataComment.loc.end : { line: sourceCode.lines.length, column: 0 }
        },
        messageId: "nameAtBeginning",
        fix: function(fixer) {
          const fixerRules = [];
          for (const attrValue of attrVal) {
            fixerRules.push(
              fixer.removeRange([
                attrValue.comment.range[0] - context.sourceCode.lines[attrValue.loc.start.line - 1].split(
                  "//"
                )[0].length - 1,
                attrValue.comment.range[1]
              ])
            );
          }
          attrVal.sort(
            (attrValue1, attrValue2) => attrValue1.key === "name" ? -1 : attrValue2.key === "name" ? 1 : 0
          );
          fixerRules.push(
            fixer.insertTextAfterRange(
              startComment.range,
              attrVal.map(
                (attrValue) => `
${context.sourceCode.lines[attrValue.loc.start.line - 1].split("//")[0]}//${attrValue.comment.value}`
              ).join("")
            )
          );
          return fixerRules;
        }
      });
    }
  },
  messages: {
    multipleNames: "Include only one name for each language",
    nameAtBeginning: "The names should be at the beginning of the metadata"
  },
  fixable: true,
  regexMatch: nameReg,
  runOnce: true
});
