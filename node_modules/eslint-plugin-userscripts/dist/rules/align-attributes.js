"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var align_attributes_exports = {};
__export(align_attributes_exports, {
  default: () => align_attributes_default
});
module.exports = __toCommonJS(align_attributes_exports);
var import_comment = require("../utils/comment");
var align_attributes_default = {
  meta: {
    type: "suggestion",
    docs: {
      description: "aligns attributes in the metadata",
      category: "Stylistic Issues"
    },
    schema: [
      {
        type: "integer",
        minimum: 1,
        default: 2
      }
    ],
    messages: {
      spaceMetadata: "The metadata is not spaced"
    },
    fixable: "code"
  },
  create: (context) => {
    var _a;
    const spacing = context.options[0] || 2;
    const sourceCode = context.sourceCode;
    const comments = sourceCode.getAllComments();
    let inMetadata = false;
    let done = false;
    const metadata = [];
    let start = null;
    let end = null;
    let maxLength = 0;
    let minSpace = Number.POSITIVE_INFINITY;
    for (const comment of comments) {
      if (done || comment.type !== "Line" || !(0, import_comment.isNonNullishComment)(comment)) {
        continue;
      }
      const commentValue = comment.value.trim();
      if (inMetadata && commentValue === "==/UserScript==") {
        end = comment.loc.end;
        done = true;
      } else if (!inMetadata && commentValue === "==UserScript==") {
        start = comment.loc.start;
        inMetadata = true;
      } else if (inMetadata && commentValue.startsWith("@")) {
        const spaceString = (_a = /^\S*(\s*)/.exec(commentValue.slice(1))) == null ? void 0 : _a[1];
        if (!spaceString || spaceString.length === 0) {
          continue;
        }
        metadata.push({
          key: commentValue.slice(1).split(/\s/)[0],
          space: spaceString.length,
          line: comment.loc.start.line,
          comment
        });
        maxLength = Math.max(maxLength, metadata.at(-1).key.length);
        minSpace = Math.min(minSpace, metadata.at(-1).space);
      }
    }
    if (!end) {
      end = sourceCode.getLocFromIndex(sourceCode.getText().length);
    }
    if (metadata.length === 0) {
      return {};
    }
    const totalSpacing = maxLength + spacing;
    const hasSpaceLessThenSpacing = minSpace < spacing;
    if (start && end && (hasSpaceLessThenSpacing || metadata.some(({ key, space }) => key.length + space !== totalSpacing))) {
      context.report({
        loc: {
          start,
          end
        },
        messageId: "spaceMetadata",
        fix: function(fixer) {
          var _a2;
          const fixerRules = [];
          for (const metadatapoint of metadata) {
            if (metadatapoint.key.length + metadatapoint.space !== totalSpacing) {
              const startColumn = (_a2 = /^(.*?@\S*)/.exec(
                sourceCode.lines[metadatapoint.line - 1]
              )) == null ? void 0 : _a2[1].length;
              if (!startColumn) {
                continue;
              }
              fixerRules.push(
                fixer.replaceTextRange(
                  [
                    sourceCode.getIndexFromLoc({
                      line: metadatapoint.line,
                      column: startColumn
                    }),
                    sourceCode.getIndexFromLoc({
                      line: metadatapoint.line,
                      column: startColumn + metadatapoint.space
                    })
                  ],
                  " ".repeat(totalSpacing - metadatapoint.key.length)
                )
              );
            }
          }
          return fixerRules;
        }
      });
    }
    return {};
  }
};
