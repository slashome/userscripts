"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var compat_grant_exports = {};
__export(compat_grant_exports, {
  default: () => compat_grant_default
});
module.exports = __toCommonJS(compat_grant_exports);
var import_createValidator = require("../utils/createValidator");
var import_compat_grant = require("../data/compat-grant");
var import_semver = require("semver");
var import_cleanupRange = require("../utils/cleanupRange");
var compat_grant_default = (0, import_createValidator.createValidator)({
  name: ["grant"],
  description: "ensures compatibility across targeted userscript managers when using grants",
  required: false,
  validator: ({ attrVal, context }) => {
    if (!context.settings.userscriptVersions) {
      return;
    }
    const requestedGrant = attrVal.val;
    const allRequired = context.options[0] && context.options[0].requireAllCompatible;
    const overrides = context.settings.userscriptGrantCompatabilityOverrides || {};
    const gmPolyfill = context.options[0] && context.options[0].gmPolyfill;
    const gmPolyfillFallback = gmPolyfill && import_compat_grant.gmPolyfillOverride[requestedGrant] ? import_compat_grant.gmPolyfillOverride[requestedGrant] : import_compat_grant.compatMap[requestedGrant];
    if (overrides[requestedGrant] === "ignore") {
      return;
    }
    const supports = [];
    function doesSupport(givenGrant) {
      const compatValue = overrides[givenGrant] || (gmPolyfill && import_compat_grant.gmPolyfillOverride[givenGrant] ? import_compat_grant.gmPolyfillOverride[givenGrant] : import_compat_grant.compatMap[givenGrant]);
      let compatVersions = Array.isArray(compatValue) ? compatValue : [];
      if (!compatValue || compatValue === "ignore") {
        return;
      }
      if ("deps" in compatValue) {
        for (const overrideDep of compatValue.deps) {
          doesSupport(overrideDep);
        }
        if ("versions" in compatValue) {
          compatVersions = compatValue.versions;
        } else {
          return;
        }
      }
      if (!Array.isArray(compatValue)) {
        if ("versions" in compatValue) {
          compatVersions = compatValue.versions;
        } else {
          return;
        }
      }
      for (const versionConstraint in context.settings.userscriptVersions) {
        const foundAssertion = compatVersions.find(
          (constraint) => constraint.type === versionConstraint
        );
        const secondAssertionFound = import_compat_grant.compatMap[givenGrant] && import_compat_grant.compatMap[givenGrant].find(
          (constraint) => constraint.type === versionConstraint
        );
        supports.push(
          (foundAssertion ? (0, import_semver.intersects)(
            (0, import_cleanupRange.cleanupRange)(
              context.settings.userscriptVersions[versionConstraint]
            ),
            (0, import_cleanupRange.cleanupRange)(foundAssertion.versionConstraint),
            true
          ) : false) || (gmPolyfill && import_compat_grant.gmPolyfillOverride[givenGrant] && secondAssertionFound ? (0, import_semver.intersects)(
            (0, import_cleanupRange.cleanupRange)(
              context.settings.userscriptVersions[versionConstraint]
            ),
            (0, import_cleanupRange.cleanupRange)(secondAssertionFound.versionConstraint),
            true
          ) : false)
        );
      }
    }
    if (overrides[requestedGrant] || gmPolyfillFallback) {
      doesSupport(requestedGrant);
    }
    if (allRequired && !supports.every((supportsIntersection) => supportsIntersection === true)) {
      context.report({
        loc: {
          start: {
            line: attrVal.loc.start.line,
            column: 0
          },
          end: attrVal.loc.end
        },
        messageId: "allNotSupportingCompatGrant",
        data: { requestedGrant }
      });
    } else if (!allRequired && supports.every(
      (supportsIntersection) => supportsIntersection === false
    ) || !gmPolyfillFallback && !overrides[requestedGrant]) {
      context.report({
        loc: {
          start: {
            line: attrVal.loc.start.line,
            column: 0
          },
          end: attrVal.loc.end
        },
        messageId: "noSupportingCompatGrant",
        data: { requestedGrant }
      });
    }
  },
  messages: {
    noSupportingCompatGrant: "None of your target versions support '{{ requestedGrant }}'",
    allNotSupportingCompatGrant: "All of your target versions don't support '{{ requestedGrant }}'"
  },
  schema: [
    {
      type: "object",
      properties: {
        requireAllCompatible: {
          type: "boolean",
          default: false
        },
        gmPolyfill: {
          type: "boolean",
          default: false
        }
      },
      default: {}
    }
  ]
});
